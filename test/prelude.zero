'' naming conventions
'' x, y, z unspecified type
'' f, g, h function type
'' n, m, k integer type
'' b, c    boolean type
'' p, q    boolean-valued function
'' m*      maybe of *
'' *s      list of *
'' **      pair of * and *

'' universal
undefined := error("undefined")  '' runtime error if this is evaluated
identity(x) := x                 '' identity function
constant(x) := _ -> x            '' return value does not depend on parameter
x.f := f(x)                      '' uniform function call syntax
f || x := f(x)                   '' low precedence application
f <> g := x -> f(g(x))           '' function composition

'' boolean logic
true(x, y) := x
false(x, y) := y
if(c, x, y) := c(x, y)
(?) := if
and(b, c) := b ? c || false
or(b, c) := b ? true || c
~b := b ? false || true
xor(b, c) := b ? ~c || c
b => c := b ? c || true
b <=> c := b ? c || ~c
(/\) := and
(\/) := or

'' pairs
(,)(x, y)(f) := f(x, y)     '' this definition is for (,) and sections
left(xy) := xy(true)
right(xy) := xy(false)
swap((x, y)) := (y, x)

'' function methods
`f(x, y) := f(y, x)      '' flip order of first two arguments of function
mirror(f)(x) := f(x, x)        '' convert binary function to unary function
on(f, g) := x -> y -> f(g(x), g(y))  '' apply binary f with unary g applied first
f^^(n)(z) := n = 0 ? z || f^^(n - 1)(f(z))
until(f, p, z) := p(z) ? z || f.until(p, f(z))
while(f, p, z) := f.until((~) <> p, z)
curry(f) := x -> y -> f((x, y))
uncurry(f) := xx -> f(left(xx), right(xx))

'' more pairs
mapPair(xx, f) := (,).on(f).uncurry(xx)

'' maybe
nothing := z -> f -> z
just(x) := z -> f -> f(x)
isNothing(mx) := mx(true, constant(false))
isJust(mx) := mx(false, constant(true))
fromJust(mx) := mx(undefined, identity)
maybe(x, f, mx) := mx(x, f)
mx ?. f := mx(nothing, f)                   '' maybe chaining (bind)
mx ?: x := mx(x, identity)                  '' just value or default

'' math
abs(n) := n >= 0 ? n || -n
min(n, m) := n <= m ? n || m
max(n, m) := n >= m ? n || m
mod(n, m) := n % m
even(n) := n.mod(2) = 0
odd(n) := n.mod(2) ~= 0
divides(n, m) := m.mod(n) = 0
factorial(n) := (n = 0) ? 1 || n * factorial(n - 1)
gcd(n, m) := (m = 0) ? n || gcd(m, n.mod(m))
n ^ m := (
    m = 0 ? 1
    m < 0 ? 1 / n ^ -m
    even(m) ? (*).mirror(n ^ (m / 2))
    n * n ^ (m - 1)
)

'' list basics
x :: xs := (x, xs)                     '' prepend element to list (cons)
prepend := `(::)
isEmpty(xs) := xs(_ -> _ -> false)
head(xs) := isEmpty(xs) ? error("head: empty list") || left(xs)
--xs := isEmpty(xs) ? error("(--): empty list") || right(xs)
take(xs, n) := n = 0 ? [] || xs.head :: (--xs).take(n - 1)
drop(xs, n) := (--)^^(n)(xs)            '' drop n elements from front of list
splitAt(xs, n) := (xs.take(n), xs.drop(n))
xs[n] := head(xs.drop(n))          '' get element of list at index
xs == ys := xs.isEmpty \/ ys.isEmpty ? xs.isEmpty <=> ys.isEmpty ||
    xs[0] = ys[0] /\ --xs == --ys       '' integer list equality
last(xs) := (--).until((== []) <> (--), xs)[0] '' get last element of list
dropLast(xs) := xs == [] \/ --xs == [] ? [] || xs[0] :: dropLast(--xs)

'' syntactic helpers
xs ::? f := isEmpty(xs) ? [] || f(head(xs), --xs)

'' list folds
foldr(xs, f, z) := isEmpty(xs) ? z || f(head(xs), foldr(--xs, f, z))
foldl(xs, f, z) := isEmpty(xs) ? z || foldl(--xs, f, f(z, head(xs)))
reducer(xs, f) := (--xs).foldr(f, xs[0])
reducel(xs, f) := (--xs).foldl(f, xs[0])

'' list fold operations
xs ++ ys := xs.foldr((::), ys)                   '' concatenate lists
length(xs) := xs.foldr(constant((+ 1)), 0)         '' get length of list
(#) := length

'' generic list constructors
iterate(f, x) := x :: iterate(f, f(x))       '' iteratively apply f
repeat(x) := x :: repeat(x)                  '' infinitely repeat one element
replicate(x, n) := (x ::)^^(n)([])         '' replicate one element n times
cycle(xs) := xs ++ cycle(xs)                 '' infinitely cycle list

'' generic list transformations
filter(xs, p) := xs.foldr(x -> xs' -> p(x) ? x :: xs' || xs', [])
(|) := filter
xs |~ p := xs | (~) <> p
map(xs, f) := xs.foldr((::) <> f, [])          '' map function over list
zipWith(xs, f, ys) := xs == [] \/ ys == [] ? [] ||
    f(xs[0], ys[0]) :: zipWith(--xs, f, --ys)
zip(xs, ys) := zipWith(xs, (,), ys)
unzip(xs) := (xs.map(left), xs.map(right))
concatenate(xss) := xss.foldr((++), [])     '' concatenate list of lists
reverse(xs) := xs.foldl(`(::), [])       '' reverse a list
interleave(xs, y) := xs ::? x -> xs' ->
    xs' == [] ? xs || x :: y :: interleave(xs', y)
join(xss, ys) := concatenate(interleave(xss, ys))

'' generic list reducers
any(xs, p) := xs.map(p).foldr((\/), false)     '' test if any element satisfies p
all(xs, p) := xs.map(p).foldr((/\), true)      '' test if all elements satisfy p
anyTrue(xs) := xs.any(identity)
allTrue(xs) := xs.all(identity)
'' find first element satisfying p, or return nothing
find(xs, p) := xs == [] ? nothing || p(xs[0]) ? just(xs[0]) || (--xs).find(p)
lookup(nxs, n) := nxs == [] ? nothing ||
    nxs[0].left = n ? just(nxs[0].right) || (--nxs).lookup(n)

'' integer list basics
n : ns := ns.any((= n))
n ~: ns := ~(n : ns)
containsSorted(ns, n) := ~(ns == []) /\ n >= ns[0] /\
        (n = ns[0] \/ (--ns).containsSorted(n))

'' integer list constructors
n .. m := n > m ? [] || n :: (n + 1 .. m)

'' integer list transformations
sort(ns) := ns ::? k -> ks -> sort(ks | (<= k)) ++ [k] ++ sort(ks | (> k))
deduplicate(ns) := ns ::? k -> ks -> k :: deduplicate(ks | (~= k))
ns \ ms := ns | (~: ms)             '' list difference
ns <: ms := ns.all((: ms))
ns ** ms := concatenate(ns.map(n -> ms.map(m -> (n, m))))
sortedDifference(ns, ms) := ns |~ ms.containsSorted  '' sorted list difference

break(ns, p) := (
    ns == [] ? ([], [])
    p(ns[0]) ? ([], ns)
    (before, after) := (--ns).break(p)
    (ns[0] :: before, after)
)

span(ns, p) := ns.break((~) <> p)

chop(ns, f) := ns == [] ? [] || (
    (a, b) := f(ns)
    a :: chop(b, f)
)

split(ns, p) := (
    (a, b) := ns.break(p)
    a :: (b == [] ? [] || (--b).split(p))
)

startsWith(ns, ks) := allTrue(zipWith(ns, (=), ks))

words(ns) := ns.split((= ' ')) |~ (== [])
lines(ns) := ns.split((= '\n'))

repl(in, prompt, f) := prompt ++ in.lines.map(f).join("\n" ++ prompt)

'' integer list reducers
sum(ns) := ns.foldl((+), 0)
product(ns) := ns.foldl((*), 1)
minimum(ns) := ns.reducel(min)
maximum(ns) := ns.reducel(max)

'' infinite lists
countFrom := iterate((+ 1))
naturals := countFrom(0)
squares := naturals.map(mirror(*))
primes := (f(ms) := ms ::? n -> ns -> n :: f(ns |~ n.divides)) f(countFrom(2))

'' character classes
isUppercase(n) := n >= 'A' /\ n <= 'Z'
isLowercase(n) := n >= 'a' /\ n <= 'z'
isDigit(n) := n >= '0' /\ n <= '9'
isQuote(n) := n = '"' \/ n = '\''
isWhitespace(n) := n = ' ' \/ n >= '\t' /\ n <= '\r'
isBlank(n) := n = ' ' \/ n = '\t'
isControl(n) := n < 32 \/ n >= 127
isAlphabetic(n) := isUppercase(n) \/ isLowercase(n)
isAlphanumeric(n) := isAlphabetic(n) \/ isDigit(n)
isPrintable(n) := ~isControl(n)
isGraphical(n) := isPrintable(n) /\ ~isBlank(n)
isPunctuation(n) := isGraphical(n) /\ ~isAlphanumeric(n)

'' serialization
showBoolean(b) := b ? "true" || "false"
showNatural(n) := (
    showReversedNatural(m) := m = 0 ? [] ||
        ('0' + m.mod(10)) :: showReversedNatural(m / 10)
    n = 0 ? "0" || reverse(showReversedNatural(n))
)

showString(ns) := "\"" ++ ns ++ "\""     '' todo: escape
showPair(xsxs) := "(" ++ xsxs.left ++ ", " ++ xsxs.right ++ ")"
showList(xs) := "[" ++ xs.join(", ") ++ "]"
showInteger(n) := (n < 0 ? "-" || "") ++ showNatural(abs(n))

showStringPair(nsns) := showPair(nsns.mapPair(showString))
showIntegerPair(nn) := showPair(nn.mapPair(showInteger))
showStringIntegerPair(nsn) := showPair(
    (showString(nsn.left), showInteger(nsn.right)))

showStringList(nss) := showList(nss.map(showString))
showIntegerList(ns) := showList(ns.map(showInteger))
showIntegerPairList(nns) := showList(nns.map(showIntegerPair))
showIntegerListPair(nsns) := showPair(nsns.mapPair(showIntegerList))
showIntegerListList(nss) := showList(nss.map(showIntegerList))
showStringIntegerPairList(nsns) := showList(nsns.map(showStringIntegerPair))

'' parsing
parseDigit(digit, base) :=
    isDigit(digit) /\ digit - '0' < base ? digit - '0' ||
    error("Invalid digit in base " ++ showInteger(base) ++ ": " ++ [digit])
parseNatural(string, base) :=
    string.foldl(x -> d -> base * x + parseDigit(d, base), 0)
parseInteger(string, base) := string.head = '-' ?
    -parseNatural(--string, base) || parseNatural(string, base)
