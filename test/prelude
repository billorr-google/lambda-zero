// naming conventions
// x, y, z unspecified type
// f, g, h function type
// n, m, k integer type
// b, c    boolean type
// p, q    boolean-valued function
// m*      maybe of *
// *s      list of *
// **      pair of * and *

// universal
undefined = error("undefined")  // runtime error if this is evaluated
identity(x) = x                 // identity function
constant(x) = y -> x            // return value does not depend on parameter

// boolean logic
true(x, y) = x
false(x, y) = y
if(c, x, y) = c(x, y)
and(b, c) = if (b) then c else false
or(b, c) = if (b) then true else c
~b = if (b) then false else true
xor(b, c) = if (b) then ~c else c
b => c = if (b) then c else true
b <=> c = if (b) then c else ~c
(/\) = and
(\/) = or
(?) = if

// pairs
(x, y) = f -> f x y             // this definition is for (,) and sections
left(xy) = xy(true)
right(xy) = xy(false)
swap(xy) = (right(xy), left(xy))

// function methods
x.f = f(x)                      // uniform function call syntax
f || x = f(x)                   // low precedence application
f <> g = x -> f(g(x))           // function composition
compose = (<>)
flip(f) = x -> y -> f(y, x)     // flip binary function argument order
mirror(f) = x -> f(x, x)        // convert binary function to unary function
on(f, g) = x -> y -> f(g(x), g(y))  // apply binary f with unary g applied first
f ^^ n = z -> if (n == 0) then z else (f ^^ n - 1)(f(z))
until(f, p, z) = if (p(z)) then z else f.until(p, f(z))
while(f, p, z) = f.until((~) <> p, z)
curry(f) = x -> y -> f((x, y))
uncurry(f) = xx -> f(left(xx), right(xx))

// more pairs
mapPair(xx, f) = (,).on(f).uncurry(xx)

// maybe
nothing = z -> f -> z
just(x) = z -> f -> f(x)
isNothing(mx) = mx(true, constant(false))
isJust(mx) = mx(false, constant(true))
fromJust(mx) = mx(undefined, identity)
maybe(x, f, mx) = mx(x, f)
mx ?. f = mx(nothing, f)                   // maybe chaining (bind)
mx ?: x = mx(x, identity)                 // just value or default

// math
abs(n) = if (n >= 0) then n else -n
min(n, m) = if (n <= m) then n else m
max(n, m) = if (n >= m) then n else m
mod(n, m) = n \ m
even(n) = n.mod(2) == 0
odd(n) = n.mod(2) =/= 0
divides(n, m) = m.mod(n) == 0
factorial(n) = if (n == 0) then 1 else n * factorial(n - 1)
gcd(n, m) = if (m == 0) then n else gcd(m, n.mod(m))
n ^ m = if (m == 0) then 1 else
    if (m < 0) then 1 / n ^ -m else
    if (even(m)) then (*).mirror(n ^ (m / 2)) else
    n * n ^ (m - 1)

// list basics
x :: xs = (x, xs)                     // prepend element to list (cons)
prepend = flip(::)
isEmpty(xs) = xs(constant(constant(false)))
head = left                  // get first element of list
tail = right                 // drop first element of list
last(xs) = head(tail.until(isEmpty <> tail, xs)) // get last element of list
index(xs, n) = head((tail ^^ n)(xs))      // get element of list at index

// syntactic helpers
xs ::? f = if (xs.isEmpty) then [] else f(xs.head, xs.tail)

// list folds
foldr(xs, f, z) = if (xs.isEmpty) then z else f(xs.head, xs.tail.foldr(f, z))
foldl(xs, f, z) = if (xs.isEmpty) then z else xs.tail.foldl(f, f(z, xs.head))
reducer(xs, f) = xs.tail.foldr(f, xs.head)
reducel(xs, f) = xs.tail.foldl(f, xs.head)

// list fold operations
xs ++ ys = xs.foldr((::), ys)                  // concatenate lists
length(xs) = xs.foldr(constant(+ 1), 0)         // get length of list
(#) = length

// generic list constructors
iterate(f, x) = x :: iterate(f, f(x))       // iteratively apply f
repeat(x) = x :: repeat(x)                  // infinitely repeat one element
replicate(x, n) = ((x ::) ^^ n)([])         // replicate one element n times
cycle(xs) = xs ++ cycle(xs)                 // infinitely cycle list

// generic list transformations
filter(xs, p) = xs.foldr(x -> xs' -> if (p(x)) then x :: xs' else xs', [])
(|) = filter
xs |~ p = xs | (~) <> p
map(xs, f) = xs.foldr((::) <> f, [])          // map function over list
zipWith(xs, f, ys) = if (xs.isEmpty \/ ys.isEmpty) then [] else
    f(xs.head, ys.head) :: zipWith(xs.tail, f, ys.tail)
zip(xs, ys) = zipWith(xs, (,), ys)
unzip(xs) = (xs.map(left), xs.map(right))
// drop all elements beyond the first n elements
take(xs, n) = if (n == 0) then [] else xs.head :: xs.tail.take(n - 1)
drop(xs, n) = (tail ^^ n)(xs)            // drop n elements from front of list
dropLast(xs) = if (xs.isEmpty \/ xs.tail.isEmpty) then [] else
    xs.head :: dropLast(xs.tail)
concatenate(xss) = xss.foldr((++), [])     // concatenate list of lists
reverse(xs) = xs.foldl(flip(::), [])       // reverse a list
interleave(xs, y) = xs ::? x -> xs' ->
    if (xs'.isEmpty) then xs else x :: y :: interleave(xs', y)
join(xss, ys) = concatenate(interleave(xss, ys))

// generic list reducers
any(xs, p) = xs.map(p).foldr((\/), false)     // test if any element satisfies p
all(xs, p) = xs.map(p).foldr((/\), true)      // test if all elements satisfy p
anyTrue(xs) = xs.any(identity)
allTrue(xs) = xs.all(identity)
// find first element satisfying p, or return nothing
find(xs, p) = if (xs.isEmpty) then nothing else
    if (p(xs.head)) then just(xs.head) else xs.tail.find(p)
lookup(nxs, n) = if (nxs.isEmpty) then nothing else
    if (nxs.head.left == n) then just(nxs.head.right) else nxs.tail.lookup(n)

// integer list basics
n : ns = ns.any((== n))
containsSorted(ns, n) = ~ns.isEmpty /\ n >= ns.head /\
        (n == ns.head \/ ns.tail.containsSorted(n))
xs === ys = if (xs.isEmpty \/ ys.isEmpty) then xs.isEmpty <=> ys.isEmpty else (
    xs.head == ys.head /\ xs.tail === ys.tail       // integer list equality
)

// integer list constructors
n .. m = if (n > m) then [] else n :: (n + 1 .. m)

// integer list transformations
sort(ns) = ns ::? k -> ks -> sort(ks | (<= k)) ++ [k] ++ sort(ks | (> k))
deduplicate(ns) = ns ::? k -> ks -> k :: deduplicate(ks | (=/= k))
ns -- ms = ns |~ (: ms)             // list difference
union(ns, ms) = ns ++ (ms -- ns)
intersect(ns, ms) = ns | (: ms)
sortedDifference(ns, ms) = ns |~ ms.containsSorted // sorted list difference

span(ns, p) = if (ns.isEmpty) then ([], []) else
    if (p(ns.head)) then (
        nsns = ns.tail.span(p)
        (ns.head :: nsns.left, nsns.right)
    ) else ([], ns)

break(ns, p) = ns.span((~) <> p)

chop(ns, f) = if (ns.isEmpty) then [] else (
    nsns = f(ns)
    nsns.left :: chop(nsns.right, f)
)

split(ns, p) = (
    nsns = ns.break(p)
    nsns.left :: (if (nsns.right.isEmpty) then [] else nsns.right.tail.split(p))
)

startsWith(ns, ks) = allTrue(zipWith(ns, (==), ks))

words(ns) = ns.split(== ' ') |~ isEmpty
lines(ns) = ns.split(== '\n')

repl(in, prompt, f) = prompt ++ in.lines.map(f).join("\n" ++ prompt)

// integer list reducers
sum(ns) = ns.foldl((+), 0)
product(ns) = ns.foldl((*), 1)
minimum(ns) = ns.reducel(min)
maximum(ns) = ns.reducel(max)

// infinite lists
countFrom = iterate(+ 1)
naturals = countFrom(0)
squares = naturals.map(mirror(*))
primes = (f(ms) = ms ::? n -> ns -> n :: f(ns |~ n.divides)) f(countFrom(2))

// character classes
isUppercase(n) = n >= 'A' /\ n <= 'Z'
isLowercase(n) = n >= 'a' /\ n <= 'z'
isDigit(n) = n >= '0' /\ n <= '9'
isQuote(n) = n == '"' \/ n == '\'' \/ n == '`'
isWhitespace(n) = n == ' ' \/ n >= '\t' /\ n <= '\r'
isBlank(n) = n == ' ' \/ n == '\t'
isControl(n) = n < 32 \/ n >= 127
isAlphabetic(n) = isUppercase(n) \/ isLowercase(n)
isAlphanumeric(n) = isAlphabetic(n) \/ isDigit(n)
isPrintable(n) = ~isControl(n)
isGraphical(n) = isPrintable(n) /\ ~isBlank(n)
isPunctuation(n) = isGraphical(n) /\ ~isAlphanumeric(n)

// serialization
showBoolean(b) = if (b) then "true" else "false"
showNatural(n) = (
    showReversedNatural(m) = if (m == 0) then [] else
        ('0' + m.mod(10)) :: showReversedNatural(m / 10)
    if (n == 0) then "0" else reverse(showReversedNatural(n))
)

showString(ns) = "\"" ++ ns ++ "\""     // todo: escape
showPair(xsxs) = "(" ++ xsxs.left ++ ", " ++ xsxs.right ++ ")"
showList(xs) = "[" ++ xs.join(", ") ++ "]"
showInteger(n) = (if (n < 0) then "-" else "") ++ showNatural(abs(n))

showStringPair(nsns) = showPair(nsns.mapPair(showString))
showIntegerPair(nn) = showPair(nn.mapPair(showInteger))
showStringIntegerPair(nsn) = showPair(
    (showString(nsn.left), showInteger(nsn.right)))

showStringList(nss) = showList(nss.map(showString))
showIntegerList(ns) = showList(ns.map(showInteger))
showIntegerPairList(nns) = showList(nns.map(showIntegerPair))
showIntegerListPair(nsns) = showPair(nsns.mapPair(showIntegerList))
showIntegerListList(nss) = showList(nss.map(showIntegerList))
showStringIntegerPairList(nsns) = showList(nsns.map(showStringIntegerPair))

// parsing

parseDigit(digit, base) =
    if (isDigit(digit) /\ digit - '0' < base) then digit - '0' else
    error("Invalid digit in base " ++ showInteger(base) ++ ": " ++ [digit])
parseNatural(string, base) =
    string.foldl(x -> d -> base * x + parseDigit(d, base), 0)
parseInteger(string, base) = if (string.head == '-') then
    -parseNatural(string.tail, base) else parseNatural(string, base)
