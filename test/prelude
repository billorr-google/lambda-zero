// naming conventions
// x, y, z unspecified type
// f, g, h function type
// n, m, k integer type
// b, c    boolean type
// p, q    boolean-valued function
// m*      maybe of *
// *s      list of *
// **      pair of * and *

// universal
undefined = error("undefined")  // runtime error if this is evaluated
identity(x) = x                 // identity function
constant(x) = y -> x            // return value does not depend on parameter
x.f = f(x)                      // uniform function call syntax
f || x = f(x)                   // low precedence application
f <> g = x -> f(g(x))           // function composition

// boolean logic
true(x, y) = x
false(x, y) = y
if(c, x, y) = c(x, y)
(?) = if
and(b, c) = b ? c || false
or(b, c) = b ? true || c
~b = b ? false || true
xor(b, c) = b ? ~c || c
b => c = b ? c || true
b <=> c = b ? c || ~c
(/\) = and
(\/) = or

// pairs
(,) = x -> y -> f -> f x y     // this definition is for (,) and sections
left(xy) = xy(true)
right(xy) = xy(false)
swap((x, y)) = (y, x)

// function methods
`f = x -> y -> f(y, x)      // flip order of first two arguments of function
mirror(f) = x -> f(x, x)        // convert binary function to unary function
on(f, g) = x -> y -> f(g(x), g(y))  // apply binary f with unary g applied first
f ^^ n = z -> n == 0 ? z || (f ^^ n - 1)(f(z))
until(f, p, z) = p(z) ? z || f.until(p, f(z))
while(f, p, z) = f.until((~) <> p, z)
curry(f) = x -> y -> f((x, y))
uncurry(f) = xx -> f(left(xx), right(xx))

// more pairs
mapPair(xx, f) = (,).on(f).uncurry(xx)

// maybe
nothing = z -> f -> z
just(x) = z -> f -> f(x)
isNothing(mx) = mx(true, constant(false))
isJust(mx) = mx(false, constant(true))
fromJust(mx) = mx(undefined, identity)
maybe(x, f, mx) = mx(x, f)
mx ?. f = mx(nothing, f)                   // maybe chaining (bind)
mx ?: x = mx(x, identity)                  // just value or default

// math
abs(n) = n >= 0 ? n || -n
min(n, m) = n <= m ? n || m
max(n, m) = n >= m ? n || m
mod(n, m) = n \ m
even(n) = n.mod(2) == 0
odd(n) = n.mod(2) =/= 0
divides(n, m) = m.mod(n) == 0
factorial(n) = n == 0 ? 1 || n * factorial(n - 1)
gcd(n, m) = m == 0 ? n || gcd(m, n.mod(m))
n ^ m = (
    m == 0 ? 1
    m < 0 ? 1 / n ^ -m
    even(m) ? (*).mirror(n ^ (m / 2))
    n * n ^ (m - 1)
)

// list basics
x :: xs = (x, xs)                     // prepend element to list (cons)
prepend = `(::)
isEmpty(xs) = xs(constant(constant(false)))
head = left                  // get first element of list
tail = right                 // drop first element of list
last(xs) = head(tail.until(isEmpty <> tail, xs)) // get last element of list
index(xs, n) = head((tail ^^ n)(xs))      // get element of list at index

// syntactic helpers
xs ::? f = xs.isEmpty ? [] || f(xs.head, xs.tail)

// list folds
foldr(xs, f, z) = xs.isEmpty ? z || f(xs.head, xs.tail.foldr(f, z))
foldl(xs, f, z) = xs.isEmpty ? z || xs.tail.foldl(f, f(z, xs.head))
reducer(xs, f) = xs.tail.foldr(f, xs.head)
reducel(xs, f) = xs.tail.foldl(f, xs.head)

// list fold operations
xs ++ ys = xs.foldr((::), ys)                   // concatenate lists
length(xs) = xs.foldr(constant(+ 1), 0)         // get length of list
(#) = length

// generic list constructors
iterate(f, x) = x :: iterate(f, f(x))       // iteratively apply f
repeat(x) = x :: repeat(x)                  // infinitely repeat one element
replicate(x, n) = ((x ::) ^^ n)([])         // replicate one element n times
cycle(xs) = xs ++ cycle(xs)                 // infinitely cycle list

// generic list transformations
filter(xs, p) = xs.foldr(x -> xs' -> p(x) ? x :: xs' || xs', [])
(|) = filter
xs |~ p = xs | (~) <> p
map(xs, f) = xs.foldr((::) <> f, [])          // map function over list
zipWith(xs, f, ys) = xs.isEmpty \/ ys.isEmpty ? [] ||
    f(xs.head, ys.head) :: zipWith(xs.tail, f, ys.tail)
zip(xs, ys) = zipWith(xs, (,), ys)
unzip(xs) = (xs.map(left), xs.map(right))
// drop all elements beyond the first n elements
take(xs, n) = n == 0 ? [] || xs.head :: xs.tail.take(n - 1)
drop(xs, n) = (tail ^^ n)(xs)            // drop n elements from front of list
dropLast(xs) = xs.isEmpty \/ xs.tail.isEmpty ? [] ||
    xs.head :: dropLast(xs.tail)
concatenate(xss) = xss.foldr((++), [])     // concatenate list of lists
reverse(xs) = xs.foldl(`(::), [])       // reverse a list
interleave(xs, y) = xs ::? x -> xs' ->
    xs'.isEmpty ? xs || x :: y :: interleave(xs', y)
join(xss, ys) = concatenate(interleave(xss, ys))

// generic list reducers
any(xs, p) = xs.map(p).foldr((\/), false)     // test if any element satisfies p
all(xs, p) = xs.map(p).foldr((/\), true)      // test if all elements satisfy p
anyTrue(xs) = xs.any(identity)
allTrue(xs) = xs.all(identity)
// find first element satisfying p, or return nothing
find(xs, p) = xs.isEmpty ? nothing ||
    p(xs.head) ? just(xs.head) || xs.tail.find(p)
lookup(nxs, n) = nxs.isEmpty ? nothing ||
    nxs.head.left == n ? just(nxs.head.right) || nxs.tail.lookup(n)

// integer list basics
n : ns = ns.any((== n))
containsSorted(ns, n) = ~ns.isEmpty /\ n >= ns.head /\
        (n == ns.head \/ ns.tail.containsSorted(n))
xs === ys = xs.isEmpty \/ ys.isEmpty ? xs.isEmpty <=> ys.isEmpty ||
    xs.head == ys.head /\ xs.tail === ys.tail       // integer list equality

// integer list constructors
n .. m = n > m ? [] || n :: (n + 1 .. m)

// integer list transformations
sort(ns) = ns ::? k -> ks -> sort(ks | (<= k)) ++ [k] ++ sort(ks | (> k))
deduplicate(ns) = ns ::? k -> ks -> k :: deduplicate(ks | (=/= k))
ns -- ms = ns |~ (: ms)             // list difference
union(ns, ms) = ns ++ (ms -- ns)
intersection(ns, ms) = ns | (: ms)
sortedDifference(ns, ms) = ns |~ ms.containsSorted // sorted list difference

break(ns, p) = (
    ns.isEmpty ? ([], [])
    p(ns.head) ? ([], ns)
    (before, after) = ns.tail.break(p)
    (ns.head :: before, after)
)

span(ns, p) = ns.break((~) <> p)

chop(ns, f) = ns.isEmpty ? [] || (
    (a, b) = f(ns)
    a :: chop(b, f)
)

split(ns, p) = (
    (a, b) = ns.break(p)
    a :: (b.isEmpty ? [] || b.tail.split(p))
)

startsWith(ns, ks) = allTrue(zipWith(ns, (==), ks))

words(ns) = ns.split(== ' ') |~ isEmpty
lines(ns) = ns.split(== '\n')

repl(in, prompt, f) = prompt ++ in.lines.map(f).join("\n" ++ prompt)

// integer list reducers
sum(ns) = ns.foldl((+), 0)
product(ns) = ns.foldl((*), 1)
minimum(ns) = ns.reducel(min)
maximum(ns) = ns.reducel(max)

// infinite lists
countFrom = iterate(+ 1)
naturals = countFrom(0)
squares = naturals.map(mirror(*))
primes = (f(ms) = ms ::? n -> ns -> n :: f(ns |~ n.divides)) f(countFrom(2))

// character classes
isUppercase(n) = n >= 'A' /\ n <= 'Z'
isLowercase(n) = n >= 'a' /\ n <= 'z'
isDigit(n) = n >= '0' /\ n <= '9'
isQuote(n) = n == '"' \/ n == '\''
isWhitespace(n) = n == ' ' \/ n >= '\t' /\ n <= '\r'
isBlank(n) = n == ' ' \/ n == '\t'
isControl(n) = n < 32 \/ n >= 127
isAlphabetic(n) = isUppercase(n) \/ isLowercase(n)
isAlphanumeric(n) = isAlphabetic(n) \/ isDigit(n)
isPrintable(n) = ~isControl(n)
isGraphical(n) = isPrintable(n) /\ ~isBlank(n)
isPunctuation(n) = isGraphical(n) /\ ~isAlphanumeric(n)

// serialization
showBoolean(b) = b ? "true" || "false"
showNatural(n) = (
    showReversedNatural(m) = m == 0 ? [] ||
        ('0' + m.mod(10)) :: showReversedNatural(m / 10)
    n == 0 ? "0" || reverse(showReversedNatural(n))
)

showString(ns) = "\"" ++ ns ++ "\""     // todo: escape
showPair(xsxs) = "(" ++ xsxs.left ++ ", " ++ xsxs.right ++ ")"
showList(xs) = "[" ++ xs.join(", ") ++ "]"
showInteger(n) = (n < 0 ? "-" || "") ++ showNatural(abs(n))

showStringPair(nsns) = showPair(nsns.mapPair(showString))
showIntegerPair(nn) = showPair(nn.mapPair(showInteger))
showStringIntegerPair(nsn) = showPair(
    (showString(nsn.left), showInteger(nsn.right)))

showStringList(nss) = showList(nss.map(showString))
showIntegerList(ns) = showList(ns.map(showInteger))
showIntegerPairList(nns) = showList(nns.map(showIntegerPair))
showIntegerListPair(nsns) = showPair(nsns.mapPair(showIntegerList))
showIntegerListList(nss) = showList(nss.map(showIntegerList))
showStringIntegerPairList(nsns) = showList(nsns.map(showStringIntegerPair))

// parsing

parseDigit(digit, base) =
    isDigit(digit) /\ digit - '0' < base ? digit - '0' ||
    error("Invalid digit in base " ++ showInteger(base) ++ ": " ++ [digit])
parseNatural(string, base) =
    string.foldl(x -> d -> base * x + parseDigit(d, base), 0)
parseInteger(string, base) = string.head == '-' ?
    -parseNatural(string.tail, base) || parseNatural(string, base)
