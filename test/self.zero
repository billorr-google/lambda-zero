isDelimiterCharacter(n) := n : " \n\0,;`()[]{}"
isReservedCharacter(n) := n : "{};@$"
isOperandCharacter(n) := isAlphanumeric(n) \/ n = '_' \/ n = '\''
isOperatorCharacter(n) := isPunctuation(n) /\ !isDelimiterCharacter(n) /\
    !isOperandCharacter(n) /\ !isQuote(n) /\ !isReservedCharacter(n)

isComment(lexeme) := lexeme.startsWith("//")
isElided(lexeme) := isBlank(lexeme[0]) \/ isComment(lexeme)

splitQuoteCharacter(ns) := (
    ns.isEmpty? ([], [])
    n := (ns[0] = '\\' /\ !(--ns =:= []))? 2 || 1
    ns.splitAt(n)
)

shiftSplit((a, b)) := b =:= [] ? (a, b) || (a ++ [b[0]], --b)

splitQuote(ns) := (
    quote := ns[0]
    (a, b) := (--ns).splitWhile((!= quote) <> head, splitQuoteCharacter)
    shiftSplit((quote :: a, b))
)

splitLexeme(ns) := (
    ns.isEmpty? []
    ns.isComment? ns.splitOn("\n")
    ns[0].isBlank? ns.splitAfter(isBlank)
    ns[0].isQuote? splitQuote(ns)
    ns[0].isOperandCharacter? ns.splitAfter(isOperandCharacter)
    ns[0].isOperatorCharacter?  ns.splitAfter(isOperatorCharacter)
    ([ns[0]], --ns)
)

advanceLocation(location, lexeme) := (
    (line, column) := location
    (lexeme[0] = '\n')? (line + 1, 1)
    (line, column + length(lexeme))
)

splitLexemes(string, splitter, location) := (
    string.isEmpty? []
    (lexeme, remaining) := splitter(string)
    nextLocation := advanceLocation(location, lexeme)
    (lexeme, location) :: remaining.splitLexemes(splitter, nextLocation)
)

scan(string) := string.splitLexemes(splitLexeme, (1, 1)) |
    (!) <> isElided <> first

showTag(x) := showPair((showString(x.first), showIntegerPair(x.second)))
//main(input) := showList(scan(input).map(showTag))

getLexeme(tag) := tag.first
getLine(tag) := tag.second.first
getColumn(tag) := tag.second.second

showPrettyTag(tag) := "'" ++ getLexeme(tag) ++ "' at line " ++
    showInteger(getLine(tag)) ++ " column " ++ showInteger(getColumn(tag))

cREFERENCE := 0
cLAMBDA := 1
cAPPLICATION := 2
cBUILTIN := 3
cINTEGER := 4
cGLOBAL := 5

cNAME := -1
cOPERATOR := -2

newReference(tag, debruijn) := ((tag, cREFERENCE), debruijn)
newName(tag) := newReference(tag, cNAME)
newOperator(tag) := newReference(tag, cOPERATOR)
newLambda(tag, parameter, body) := ((tag, cLAMBDA), (parameter, body))
newApplication(tag, left, right) := ((tag, cAPPLICATION), (left, right))
newBuiltin(tag, code) := ((tag, cBUILTIN), code)
newInteger(tag, value) := ((tag, cINTEGER), value)
newGlobal(tag, code) := ((tag, cGLOBAL), code)

getTag(node) := node.first.first
getType(node) := node.first.second
getData(node) := node.second
getParameter(node) := getData(node).first
getBody(node) := getData(node).second
getFunction(node) := getData(node).first
getArgument(node) := getData(node).second

isReference(node) := node.getType = cREFERENCE
isName(node) := isReference(node) /\ node.getData = cNAME
isOperator(node) := isReference(node) /\ node.getData = cOPERATOR
isSymbol(node) := isName(node) \/ isOperator(node)
isLambda(node) := node.getType = cLAMBDA
isApplication(node) := node.getType = cAPPLICATION
isBuiltin(node) := node.getType = cBUILTIN
isInteger(node) := node.getType = cINTEGER
isGlobal(node) := node.getType = cGLOBAL

isNameLexeme(lexeme) := isOperandCharacter(lexeme[0]) /\ !isDigit(lexeme[0])
isOperatorLexeme(lexeme) :=
    isOperatorCharacter(lexeme[0]) \/ isDelimiterCharacter(lexeme[0])
isIntegerLexeme(lexeme) := lexeme.all(isDigit)

cX := newName(("x", (0, 0)))
cY := newName(("y", (0, 0)))
cZ := newName(("z", (0, 0)))

newNil(tag) :=
    newLambda(tag, cZ,
        newLambda(getTag(cX), cX,
            newLambda(getTag(cY), cY,
                newReference(getTag(cX), 2))))

prependList(character, list) :=
    newLambda(getTag(list), cX,
        newApplication(getTag(list),
            newApplication(getTag(list), cX, character), list))

parseEscapeCode(code, tag) := (
    code = '0' ? '\0'
    code = 'n' ? '\n'
    code = 't' ? '\t'
    code = 'r' ? '\r'
    code = '\\' ? '\\'
    code = '\"' ? '\"'
    code = '\'' ? '\''
    error("Error: invalid escape sequence after" ++ showPrettyTag(tag))
)

parseQuotedCharacter(tag, string) := (
    string[0] != '\\' ?
        newInteger(tag, string[0])
    --string =:= [] ?
        error("Error: missing escape code in " ++ showPrettyTag(tag))
    newInteger(tag, parseEscapeCode((--string)[0], tag))
)

splitStringLiteral(string) := (
    string =:= [] ? []
    n := (string[0] = '\\' /\ !(--string =:= [])) ? 2 || 1
    string.take(n) :: splitStringLiteral(string.drop(n))
)

buildStringLiteral(tag, characters) := (
    characters =:= [] ? newNil(tag)
    prependList(characters[0], buildStringLiteral(tag, --characters))
)

getQuoteContents(tag) := (
    lexeme := getLexeme(tag)
    (lexeme.last = lexeme[0])? dropLast(--lexeme)
    error("Error: missing end quote for " ++ showPrettyTag(tag))
)

getQuotedCharacters(tag) :=
    splitStringLiteral(getQuoteContents(tag)).map(parseQuotedCharacter(tag))

parseStringLiteral(tag) := buildStringLiteral(tag, getQuotedCharacters(tag))

parseCharacterLiteral(tag) := (
    characters := getQuotedCharacters(tag)
    (characters.length = 1)? characters[0]
    error("Error: invalid character literal " ++ showPrettyTag(tag))
)

createToken(tag) := (
    lexeme := getLexeme(tag)
    (lexeme[0] = '"')? parseStringLiteral(tag)
    (lexeme[0] = '\'')? parseCharacterLiteral(tag)
    isIntegerLexeme(lexeme)? newInteger(tag, parseInteger(lexeme, 10))
    isNameLexeme(lexeme)? newName(tag)
    isOperatorLexeme(lexeme)? newOperator(tag)
    error("Error: invalid token " ++ showPrettyTag(tag))
)

lex(string) := scan(string).map(createToken)

showLexeme(lexeme) := (lexeme[0] = '\n')? "\\n" || lexeme
showToken(token) := showLexeme(getLexeme(getTag(token)))
showAST(node) := (
    node.isReference?
        showToken(node) ++ "#" ++ showInteger(getData(node))
    node.isLambda?
        showToken(getParameter(node)) ++ " -> " ++ showAST(getBody(node))
    node.isApplication?
        "(" ++ showAST(getFunction(node)) ++ " " ++
               showAST(getArgument(node)) ++ ")"
    node.isInteger?
        "#" ++ showInteger(getData(node))
    showToken(node)
)

main(input) := showList(lex(input).map(showAST))
