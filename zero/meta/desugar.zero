
isDefinition(node) := isApplication(node) /\ getLexeme(node) =:= ":="

hasRecursiveCalls(node, name) := (
    isLambda(node) ? (
        getLexeme(getParameter(node)) =:= getLexeme(name) ? (
            isInternal(getParameter(node)) ? false
            syntaxError("symbol already defined", getParameter(node))
        )
        hasRecursiveCalls(getBody(node), name)
    )
    isApplication(node) ?
        hasRecursiveCalls(getLeft(node), name) \/
        hasRecursiveCalls(getRight(node), name)
    isSymbol(node) \/ isReference(node) ?
        getLexeme(node) =:= getLexeme(name)
    false
)

transformRecursion(name, value) := (
    !isSymbol(name) \/ !hasRecursiveCalls(value, name) ? value
    newApplication(getTag(name), yCombinator,
        newLambda(getTag(name), newName(getTag(name)), value))
)

getNameAndValue(left, right) := (
    !isApplication(left) ? (left, transformRecursion(left, right))
    getNameAndValue(getLeft(left),
        newLambda(getTag(getRight(left)), getRight(left), right))
)

transformDefinition(left, right, explicitScope) := (
    (name, value) := getNameAndValue(left, right)
    scope := isEOF(explicitScope) ? name || explicitScope
    transform := newPatternLambda(getTag(name), name, scope)
    newApplication(getTag(name), transform, value)
)

desugar(node) := (
    tag := getTag(node)
    isLambda(node) ? newLambda(tag, getParameter(node), desugar(getBody(node)))
    isApplication(node) ? (
        isDefinition(node) ? (
            isDefinition(getLeft(node)) ?
                syntaxError("cannot define a definition", node)
            transformDefinition(
                desugar(getLeft(node)), desugar(getRight(node)), eof)
        )
        isDefinition(getLeft(node)) ?
            transformDefinition(desugar(getLeft(getLeft(node))),
                desugar(getRight(getLeft(node))), desugar(getRight(node)))
        newApplication(getTag(node),
            desugar(getLeft(node)), desugar(getRight(node)))
    )
    node        // all leaf nodes are returned unmodified
)
