isOpenParen(node) := isOperator(node) /\ getLexeme(getTag(node)) =:= "("
isCloseParen(node) := isOperator(node) /\ getLexeme(getTag(node)) =:= ")"
isSpace(node) := isOperator(node) /\ isBlank(getLexeme(getTag(node))[0])
isNewline(node) := isOperator(node) /\ getLexeme(getTag(node)) =:= "\n"
isEOF(node) := isOperator(node) /\ getLexeme(getTag(node)) =:= "\0"

isNameLexeme(lexeme) := isOperandCharacter(lexeme[0]) /\ !isDigit(lexeme[0])
isOperatorLexeme(lexeme) :=
    isOperatorCharacter(lexeme[0]) \/ isDelimiterCharacter(lexeme[0])
isIntegerLexeme(lexeme) := lexeme.all(isDigit)

showLexeme(lexeme) := (
    lexeme.isEmpty \/ lexeme[0] = 0 ? "\\0"
    lexeme[0] = '\n' ? "\\n"
    lexeme
)

showToken(token) := showLexeme(getLexeme(getTag(token)))

showLocation(tag) :=
    "line " ++ showNatural(getLine(tag)) ++
    " column " ++ showNatural(getColumn(tag))

showLexemeAndLocationLine(tag, quote) :=
    quote ++ showLexeme(getLexeme(tag)) ++ quote ++
        " at " ++ showLocation(tag) ++ "\n"

blank := newName(("_", (0, 0)))
cT := newName(("t", (0, 0)))
cF := newName(("f", (0, 0)))
cZ := newName(("z", (0, 0)))
eof := newOperator(("\0", (0, 0)))

newTrue(tag) := newLambda(tag, cT, newLambda(tag, cF,
    newReference(getTag(cT), 1)))
newFalse(tag) := newLambda(tag, cT, newLambda(tag, cF,
    newReference(getTag(cF), 0)))
newBoolean(tag, b) := b ? newTrue(tag) || newFalse(tag)
newNil(tag) := newLambda(tag, cZ, newTrue(tag))

prependList(character, list) :=
    newLambda(getTag(list), blank,
        newApplication(getTag(list),
            newApplication(getTag(list), blank, character), list))

parseEscapeCode(code, tag) := (
    code = '0' ? '\0'
    code = 'n' ? '\n'
    code = 't' ? '\t'
    code = 'r' ? '\r'
    code = '\\' ? '\\'
    code = '\"' ? '\"'
    code = '\'' ? '\''
    error("Error: invalid escape sequence after" ++ showPrettyTag(tag))
)

parseQuotedCharacter(tag, string) := (
    string[0] != '\\' ?
        newInteger(tag, string[0])
    --string =:= [] ?
        error("Error: missing escape code in " ++ showPrettyTag(tag))
    newInteger(tag, parseEscapeCode((--string)[0], tag))
)

splitStringLiteral(string) := (
    string =:= [] ? []
    n := (string[0] = '\\' /\ !(--string =:= [])) ? 2 || 1
    string.take(n) :: splitStringLiteral(string.drop(n))
)

buildStringLiteral(tag, characters) := (
    characters =:= [] ? newNil(tag)
    prependList(characters[0], buildStringLiteral(tag, --characters))
)

getQuoteContents(tag) := (
    lexeme := getLexeme(tag)
    (lexeme.last = lexeme[0])? dropLast(--lexeme)
    error("Error: missing end quote for " ++ showPrettyTag(tag))
)

getQuotedCharacters(tag) :=
    splitStringLiteral(getQuoteContents(tag)).map(parseQuotedCharacter(tag))

parseStringLiteral(tag) := buildStringLiteral(tag, getQuotedCharacters(tag))

parseCharacterLiteral(tag) := (
    characters := getQuotedCharacters(tag)
    (characters.length = 1)? characters[0]
    error("Error: invalid character literal " ++ showPrettyTag(tag))
)

createInteger(tag) := (
    lexeme := getLexeme(tag)
    maxInteger := "9223372036854775807"
    integer := lexeme.dropIf((= '0'))
    integer.length > maxInteger.length ?
        error("Syntax error: magnitude of integer is too large " ++
            showLexemeAndLocationLine(tag, "'"))
    integer.length = maxInteger.length /\
        zipWith(integer, (>), maxInteger).any() ?
        error("Syntax error: magnitude of integer is too large " ++
            showLexemeAndLocationLine(tag, "'"))
    newInteger(tag, parseInteger(lexeme, 10))
)

createToken(tag) := (
    lexeme := getLexeme(tag)
    (lexeme[0] = '"')? parseStringLiteral(tag)
    (lexeme[0] = '\'')? parseCharacterLiteral(tag)
    isIntegerLexeme(lexeme)? createInteger(tag)
    isNameLexeme(lexeme)? newName(tag)
    isOperatorLexeme(lexeme)? newOperator(tag)
    error("Error: invalid token " ++ showPrettyTag(tag))
)

syntaxError(message, token) :=
    error("Syntax error: " ++ message ++ " " ++
        showLexemeAndLocationLine(getTag(token), "'"))

lex(string) := scan(string).map(createToken)
